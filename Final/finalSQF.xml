<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0">
    <info>
        <title>Schematron QuickFix</title>
        <author>
            <personname><firstname>Octavian</firstname>
                <surname>Nadolu</surname></personname>
            <affiliation>
                <orgname>oXygen XML Editor</orgname>
            </affiliation>
            <email>octavian_nadolu@oxygenxml.com</email>
        </author>
        <author>
            <personname><firstname>Nico</firstname>
                <surname>Kutscherauer</surname></personname>
            <affiliation>
                <orgname>data2type GmbH</orgname>
            </affiliation>
            <email>kutscherauer@schematron-quickfix.com</email>
            <email>kutscherauer@data2type.de</email>
        </author>
        <abstract>
            <para>Fixing XML validation errors can be challenging for many users, especially if they
                are not very familiar with XML syntax and structure. For many years, development
                tools have provided ways to allow users to select actions that automatically fix
                reported issues for certain programming languages (such as Java, C, etc.). This
                functionality is usually called "Quick Fixes". In a similar way, XML tools provide
                Quick Fixes for XML validation errors. For instance, Eclipse has included XML Quick
                Fixes for over 10 years. Another example of this idea is the spell checking
                functionality, which provides a list of possible corrections and allows the user to
                select one of them as a replacement for an incorrect word.</para>
            <para>The validation of XML documents against DTD, XML Schema, or RELAX NG schema
                provides a limited set of possible problems and is usually only able to detect basic
                structural errors (such as a missing element or attribute) and the corresponding
                automatic fixes are usually rather straightforward. A more interesting case would be
                if you are using Schematron to identify issues in XML documents, as the fixes in
                this case may range from trivial to very complex and there is no automatic way of
                fixing them.</para>
            <para>Schematron solves the limitation that other types of schema have when validating
                XML documents because it allows the schema author to define the errors and control
                the messages that are presented to the user. Thus the validation errors are more
                accessible to users and it ensures that they understand the problem. These messages
                may also include hints for what the user can do to fix the problem, but this creates
                a gap because the user still needs to manually correct the issue. This could cause
                people to waste valuable time and creates the possibility of making additional
                errors while trying to manually fix the reported problem. Providing a Quick Fix
                functionality for Schematron validation errors will bridge this gap, saving time and
                avoiding the potential for causing other issues.</para>
            <para>Two years ago, the idea of Schematron QuickFix (SQF) was discussed during the XML
                Prague conference and it started to take shape. It has now reached a point where we
                have a draft specification available, a W3C community group dedicated to <link
                    xlink:href="https://www.w3.org/community/quickfix/">XML Quick Fixes</link>, and
                two independent SQF implementations. The first draft of the Schematron QuickFix
                specification was published in April, 2015 and it is now available on <link
                    xlink:href="http://schematron-quickfix.github.io/sqf">GitHub</link> and within
                the W3C "Quick-Fix Support for XML Community Group".</para>
            <para>Schematron QuickFix defines a simple language to specify the actions that will be
                used to fix the detected issues, layered on top of XPath and XSLT, and integrated
                within Schematron schemas through the Schematron annotation support.</para>
            <para>In this session, we will present various use cases that are solved with Schematron
                QuickFixes, ranging from simple to complex, sometimes involving changes in multiple
                locations within a document, or even in external documents. We will also discuss the
                language and technological challenges related to the SQF implementation. Join us to
                learn how SQF can be useful in your next XML project!</para>
            <para> </para>
        </abstract>
    </info>
    <sect1>
        <title>Introduction</title>
        <para>Helping users to solve errors from XML documents has always been a challenge. There
            are various solutions to generate automatically the proposals that fix the errors and
            present them to the user. The fix proposals can be generated by the validation engine,
            or based on the error messages, or on error codes that we get from the validation
            engine. However, a language that can allow the developer to define fixes is more
            powerful and flexible. </para>
        <para>Schematron has become more and more popular in the XML world. Companies are using
            Schematron to enforce business rules to their documents and to verify the quality of
            their documents. Schematron schema is a language that defines rules for the structure
            and content that an XML document should follow.</para>
        <para>The Schematron QuickFix (SQF) has been developed as an extension of the Schematron
            schema language. It is a language that allows developers to define fixes for the
            Schematron validation errors. </para>
    </sect1>
    <sect1>
        <title>Validation Errors</title>
        <para>From the user point of view the validation error can be described by three things: the
            validation message, the location of the error (system ID and position in the document),
            and how to fix this error.</para>
        <figure>
            <title>Validation Errors</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="validationErrorMsg.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <figure>
            <title>Validation Error Description</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="validationError.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>When an XML document is validated against an XSD, RNG or DTD schema, the error
            messages refer more to the XML syntax of the document and are not easily understood by
            the user. To fix this type of errors, the user must understand the validation messages,
            check the location of the problems, and determine what operations must be done.</para>
        <para>For the validation of an XML document against a Schematron schema, the errors are in
            fact constraints or business rules and are meant to be more easily understood by the
            user. The Schematron developer can better explain what operations should be done in
            order to fix the problem because they can use custom messages. Also, the location of the
            problem can be specified in the Schematron schema.</para>
        <para>However, in both cases, to fix the error the user must do the operations manually and
            this can result in generating even more errors. The automation of the error-fixing
            process will help the user to solve the problem faster and with fewer errors.</para>
        <para>A good example of error fixing is a spell checker. A spell checker presents errors but
            also offers a set of solutions to fix them. Similarly, solutions can be generated for
            XML validation errors.</para>
    </sect1>
    <sect1>
        <title>Fixing Validation Errors</title>
        <para>Over the course of time various IDEs (such as Eclipse or IntelliJ IDEA) have
            implemented fixes for XML validation errors. In these cases, the implementation was made
            directly in the engine. However, it will be better to have an implementation that does
            not depend on the validation engine. A way to solve this is by analyzing the validation
            message, error code, and the error location that the engine provides.</para>
        <para>We can say that the validation errors can be split in two categories:</para>
        <para>
            <itemizedlist>
                <listitem>
                    <para>Predefined – defined in the validation engine. This is the case when an
                        XML document is validated against an XSD, RNG, or DTD schema.</para>
                </listitem>
                <listitem>
                    <para>Custom – defined by the user. When an XML document is validated against a
                        Schematron schema.</para>
                </listitem>
            </itemizedlist>
        </para>
        <sect2>
            <title>Fixing Predefined Errors</title>
            <para>For the predefined errors, fixes can be provided automatically based on the
                message, error code (if there is one), and location of the error. A limitation of
                this approach could be that each validation engine might provide its own predefined
                messages and error codes. Therefore, you will need an implementation for each
                validation engine.</para>
            <para>However, by providing fix proposals for these type of errors, the user will be
                helped with not only solving the problem, but also understanding it. The messages
                from the validation processor are often difficult to understood for basic users. For
                example, when an ID definition is missing, you might get the following error
                message:</para>
            <para><errortext>cvc-id.1: There is no ID/IDREF binding for IDREF
                    'robert.tayor'.</errortext>
            </para>
            <para>It would be more appropriate to have a more understandable message, such as:
                "There is an invalid ID reference: 'robert.tayor'. Would you like to change it to a
                similar ID: 'robert.taylor'?"</para>
            <para>Another example could be when an XSL document is validated and we have an
                undeclared function. This might cause the following error to be presented:</para>
            <para><errortext>XPST0017 XPath syntax error at char 0 on line 1802 near {...x($boxID,
                    func:getButtonId(...}: Cannot find a matching 2-argument function named
                    {http://www.oxygenxml.com/doc/xsl/functions}createBox()</errortext></para>
            <para>In this case, a more appropriate way to present the error might be: "The function
                'func:getButtonId()' has not been defined. Would you like to create this function or
                reference a function with a similar name?"</para>
            <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="xslErr.png"/>
                    </imageobject>
                </inlinemediaobject></para>
            <?oxy_custom_start type="oxy_content_highlight" color="180,215,3"?>
        </sect2>
        <?oxy_custom_end?>
        <sect2>
            <title>Fixing Custom Errors</title>
            <para>When an XML document is validated against a Schematron schema, we obtain our own
                customized errors. The errors are defined in the Schematron schema using the
                    <code>sch:assert</code> and <code>sch:report</code> elements. In this case, it
                is difficult, and almost impossible, to generate a fix based on the error message
                and location. </para>
            <para>Therefore, a solution to propose fixes for this type of errors is to define the
                fixes directly in the schema. A Schematron developer can create fixes and associate
                them with the <emphasis>assert</emphasis> or <emphasis>report</emphasis> message.<mediaobject>
                    <imageobject>
                        <imagedata fileref="SQFFix.png"/>
                    </imageobject>
                </mediaobject></para>
            <para>These fixes can be defined using the annotations support from Schematron.
                Schematron allows elements and attributes from other namespaces to be added as
                annotations in the schema. Thus, the validation of the Schematron will not be
                affected if new elements and attributes are added in the schema. </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Schematron Quick Fixes</title>
        <para>To allow users to create fixes for the Schematron error messages, the Schematron
            QuickFix (SQF) language was created as an extension of Schematron. Using the SQF
            language, users can define fixes for <emphasis>assert</emphasis> or
                <emphasis>report</emphasis> error messages. </para>
        <para>The Schematron QuickFix has been defined as a simple but powerful language. It defines
            some basic operations that need to be implemented by the processor.</para>
        <figure xml:id="simple_example">
            <title>Simple Schematron QuickFix example</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="sqf_Lang1.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>The operations can be done with precision in a specified place and you do not need to
            modify the entire document.</para>
        <para>The first draft of the Schematron QuickFix specification was published in April 2015
            on the <link xlink:href="https://www.w3.org/community/quickfix/">W3C community
                group</link> page.</para>
        <sect2>
            <title>SQF Benefits</title>
            <para>The Schematron schema can be used to validate any type of XML document. Thus,
                business rules or constraints can be defined for projects containing DITA, DocBook,
                XHTML, or TEI documents, and also for stylesheets or XML Schemas.</para>
            <para>For DITA, DocBook, XHTML, or TEI documents, simple styling rules can be imposed,
                such as:</para>
            <itemizedlist>
                <listitem>
                    <para>The title should not contain bold.</para>
                </listitem>
                <listitem>
                    <para>A list should contain more than one list item.</para>
                </listitem>
            </itemizedlist>
            <para>Also, more complex rules can be added, such as: <itemizedlist>
                    <listitem>
                        <para>Ensure that the table layout is correct.</para>
                    </listitem>
                    <listitem>
                        <para>All text needs to be normalized (NFC).</para>
                    </listitem>
                </itemizedlist></para>
            <para>For XSLT, XSD, or RNG documents, you can define coding styles, such as: </para>
            <itemizedlist>
                <listitem>
                    <para>The name of the variables must not contain '-', and it is recommended to
                        be camel case.</para>
                </listitem>
                <listitem>
                    <para>The name length of templates and functions should not exceed a specified
                        value.</para>
                </listitem>
            </itemizedlist>
            <para>Some of these rules can be solved very easily, while a less experienced user might
                make mistakes and add other errors. On the other hand, a user with experience might
                be able solve them rather easily, but might need to perform a few operations.</para>
            <para>For more complex problems (for instance, problems that will update multiple nodes
                in the document or make complex conversions), it would be better to have an action
                to do this automatically.</para>
        </sect2>
        <sect2>
            <title>SQF Implementations</title>
            <para>An SQF fix consists of a set of operations that must be performed in an XML
                document. These are basic operations (add, delete, replace, and string replace) that
                needs to make precise changes in the document. This means that when a quick fix is
                applied, only the affected part of the XML document should be changed and the
                DOCTYPE declaration, entities, etc. must be preserved.</para>
            <para>There are two types of implementations that can be used to execute Schematron
                Quick Fixes:<itemizedlist>
                    <listitem>
                        <para>Using an engine (implemented in Java, C, or other language) that will
                            collect the fixes during the Schematron validation process, and will
                            perform the modification precisely (using the engine programming
                            language) when the fix is applied. </para>
                    </listitem>
                    <listitem>
                        <para>Using an XSLT engine that will generate a set of XSLT scripts during
                            the Schematron validation process, and these scripts will be applied
                            when the fix is executed.</para>
                    </listitem>
                </itemizedlist></para>
        </sect2>
    </sect1>
    <sect1>
        <title>Schematron QuickFix Language</title>
        <para>As in the example above (see <xref linkend="simple_example"/>), the QuickFix (defined
            by the <code>sqf:fix</code> element) is structured as follows: </para>
        <itemizedlist>
            <listitem>
                <para><emphasis>ID</emphasis> –  Used to reference the QuickFix by
                        <code>sch:assert</code> or <code>sch:report</code> elements.</para>
            </listitem>
            <listitem>
                <para><emphasis>Title and description</emphasis> – The <emphasis>title</emphasis> is
                    used to describe the operation of the QuickFix with a short label. The optional
                        <emphasis>description</emphasis> can be used as additional information for
                    the user.</para>
            </listitem>
            <listitem>
                <para><emphasis>Operation</emphasis> – The <emphasis>Activity Elements</emphasis>
                    that specify the actions of the QuickFix.</para>
            </listitem>
            <listitem>
                <para><emphasis>Additional features</emphasis> – There are also some additional
                    features that had no place in our simple example (such as <emphasis>User
                        Entries</emphasis> and <code>use-when</code> conditions).</para>
            </listitem>
        </itemizedlist>
        <sect2>
            <title>Reference a QuickFix</title>
            <para>To reference a QuickFix, the <code>sch:assert</code> or <code>sch:report</code>
                element needs a <code>sqf:fix</code> attribute with the ID of the QuickFix. In many
                cases there are multiple possible solutions for one error, and the
                    <code>sqf:fix</code> attribute is able to reference to more than one QuickFix.
                In this case, the <code>sqf:fix</code> attribute should have a list of those
                QuickFix IDs (separated with whitespaces) that should be referenced:</para>
            <example>
                <title>Reference to Multiple QuickFixes</title>
                <programlisting>&lt;sch:rule context="title">
    &lt;sch:report test="exists(b)" 
                sqf:fix="<emphasis role="bold">resolveBold deleteBold</emphasis>"> 
Bold element is not allowed in title.&lt;/sch:report>
    &lt;sqf:fix id="<emphasis role="bold">resolveBold</emphasis>">
        &lt;sqf:description>
            &lt;sqf:title>Change the bold element into text
            &lt;/sqf:title>
            &lt;sqf:p>Remove the bold (b) markup and keeps the 
                   text content&lt;/sqf:p>
        &lt;/sqf:description>
        &lt;sqf:replace match="b" select="text()"/>
    &lt;/sqf:fix>
    &lt;sqf:fix id="<emphasis role="bold">deleteBold</emphasis>">
        &lt;sqf:description>
            &lt;sqf:title>Delete the bold element&lt;/sqf:title>
            &lt;sqf:p>Remove the bold (b) markup including the 
                   text content&lt;/sqf:p>
        &lt;/sqf:description>
        &lt;sqf:delete match="b"/>
    &lt;/sqf:fix>
&lt;/sch:rule></programlisting>
            </example>
            <sect3>
                <title>Scope</title>
                <para>The referenced QuickFix needs to be in the scope of the
                        <code>sch:report</code> or <code>sch:assert</code> element. It is in the
                    scope if the <code>sqf:fix</code> element is a child of the same
                        <code>sch:rule</code> element (which contains the <code>sch:report</code> or
                        <code>sch:assert</code> element) or if the QuickFix was defined globally. To
                    define a QuickFix globally, the top-level element <code>sqf:fixes</code> should
                    contain one or more <code>sqf:fix</code> elements. QuickFixes that are specified
                    in this way are available for all <code>sch:report</code> or
                        <code>sch:assert</code> elements of the schema. </para>
                <example>
                    <title>Global QuickFixes</title>
                    <programlisting>&lt;sch:schema xmlns:sch="http://purl.oclc.org/dsdl/schematron" 
xmlns:sqf="http://www.schematron-quickfix.com/validator/process"
queryBinding="xslt2">
    &lt;sch:pattern>
        &lt;sch:rule context="title">
            &lt;sch:report test="exists(b)" 
                        sqf:fix="resolveBold deleteBold"> 
            Bold element is not allowed in title.&lt;/sch:report>
        &lt;/sch:rule>
    &lt;/sch:pattern>
    <emphasis role="bold">&lt;sqf:fixes></emphasis>
        &lt;sqf:fix id="resolveBold">
            &lt;sqf:description>
                &lt;sqf:title>Change the bold element into text
                &lt;/sqf:title>
                &lt;sqf:p>Remove the bold (b) markup and keeps the 
                       text content&lt;/sqf:p>
            &lt;/sqf:description>
            &lt;sqf:replace match="b" select="text()"/>
        &lt;/sqf:fix>
        &lt;sqf:fix id="deleteBold">
            &lt;sqf:description>
                &lt;sqf:title>Delete the bold element&lt;/sqf:title>
                &lt;sqf:p>Remove the bold (b) markup including the 
                       text content&lt;/sqf:p>
            &lt;/sqf:description>
            &lt;sqf:delete match="b"/>
        &lt;/sqf:fix>
    <emphasis role="bold">&lt;/sqf:fixes></emphasis>
&lt;/sch:schema></programlisting>
                </example>
            </sect3>
            <sect3>
                <title>QuickFix Groups</title>
                <para>To avoid long lists of IDs, it is possible to reference a <emphasis>QuickFix
                        group</emphasis>. A QuickFix group is a set of QuickFixes and a reference to
                    a QuickFix group is equal to a reference to each QuickFix in this group. </para>
                <example>
                    <title>Reference to a QuickFix Group</title>
                    <programlisting>&lt;sch:report test="exists(b)" 
    <emphasis role="bold">sqf:fix="bold"</emphasis>> 
    Bold element is not allowed in title.&lt;/sch:report><emphasis role="bold">
&lt;sqf:group id="bold"></emphasis>
    &lt;sqf:fix id="resolveBold">
        &lt;sqf:description>
            &lt;sqf:title>Change the bold element into text
            &lt;/sqf:title>
            &lt;sqf:p>Remove the bold (b) markup and keeps the 
                text content&lt;/sqf:p>
        &lt;/sqf:description>
        &lt;sqf:replace match="b" select="text()"/>
    &lt;/sqf:fix>
    &lt;sqf:fix id="deleteBold">
        &lt;sqf:description>
            &lt;sqf:title>Delete the bold element&lt;/sqf:title>
            &lt;sqf:p>Remove the bold (b) markup including the 
                text content&lt;/sqf:p>
        &lt;/sqf:description>
        &lt;sqf:delete match="b"/>
    &lt;/sqf:fix><emphasis role="bold">
&lt;/sqf:group></emphasis></programlisting>
                    <para>To reference a QuickFix group, the <code>sqf:group</code> element also has
                        an <code>id</code> attribute. For the <code>sch:assert</code> or
                            <code>sch:report</code> elements, there is no difference between
                        referencing a QuickFix or QuickFix group.</para>
                </example>
                <para>A QuickFix group can also be defined globally (in an <code>sqf:fixes</code>
                    element) or locally (in an <code>sch:rule</code> element).</para>
            </sect3>
        </sect2>
        <sect2>
            <title>Title and Description</title>
            <para>The title (<code>sqf:title</code> element) is very important for a QuickFix. It is
                a challenge for the developer to create short titles that provide the user with
                enough information to understand what will happen when the QuickFix is executed. As
                an additional tool, the developer can deliver more information by using
                    <code>sqf:p</code> elements.</para>
            <para>Also, as with Schematron error messages, the title and optional description can be
                customized by using the Schematron elements <code>sch:value-of</code> or
                    <code>sch:name</code>.</para>
            <example>
                <title>Customized Title and Description</title>
                <programlisting>&lt;sqf:fix id="delete">
    &lt;sqf:description>
        &lt;sqf:title>Delete the <emphasis role="bold">&lt;sch:name/></emphasis> element&lt;/sqf:title>
        &lt;sqf:p>The <emphasis role="bold">&lt;sch:name/></emphasis> element was missplaced in the 
               <emphasis role="bold">&lt;sch:name path=".."/></emphasis> element.&lt;/sqf:p>
        &lt;sqf:p>This QuickFix will delete the <emphasis role="bold">&lt;sch:name/></emphasis> 
               element<emphasis role="bold">&lt;sch:value-of select="
               if (./node()) 
             then ' with all its content.' 
             else '.'"/></emphasis>
        &lt;/sqf:p>
    &lt;/sqf:description>
    &lt;sqf:delete/>
&lt;/sqf:fix></programlisting>
            </example>
            <para>This QuickFix deletes the context node of the error (matched by the
                    <code>sch:rule</code> element). This is a common solution, and if specified in
                this way, it can be reused in various contexts.</para>
        </sect2>
        <sect2>
            <title>Activity Elements</title>
            <para>After the description, the developer should specify what the QuickFix should
                actually do. To define actions, the developer can choose between four types of
                    <emphasis>Activity Elements</emphasis>. </para>
            <para>The developer can also add any number of Activity Elements from the same or
                different kinds to one QuickFix. Each Activity Element will be executed separately,
                in the context of the node, which was the context of the error (matched by the
                    <code>sch:rule</code> element).</para>
            <para>All Activity Elements have a <code>match</code> attribute to select nodes by
                XPath, relative to the context node of the error. These nodes are called anchor
                nodes. The kind of processing of the anchor nodes depends on the kind, additional
                attributes and the content of the Activity element. An Activity Element which has no
                    <code>match</code> attribute, selects the context of the error as its anchor
                node.</para>
            <para>This are the four Activity Elements:</para>
            <itemizedlist>
                <listitem>
                    <para><code>sqf:delete</code></para>
                </listitem>
                <listitem>
                    <para><code>sqf:replace</code></para>
                </listitem>
            </itemizedlist>
            <itemizedlist>
                <listitem>
                    <para><code>sqf:add</code></para>
                </listitem>
                <listitem>
                    <para><code>sqf:stringReplace</code></para>
                </listitem>
            </itemizedlist>
            <sect3>
                <title>Delete nodes</title>
                <para>The delete action is the simplest kind of the Activity elements. The
                        <code>sqf:delete</code> element deletes the anchor nodes.</para>
                <example>
                    <title>Delete the error context</title>
                    <programlisting>&lt;sch:rule context="p">
    &lt;sch:report test="normalize-space(.) = ''" 
        sqf:fix="delete"> 
        &lt;sch:name/> element without text is not allowed.&lt;/sch:report>
    &lt;sqf:fix id="delete">
        &lt;sqf:description>
            &lt;sqf:title>Delete the &lt;sch:name/> element&lt;/sqf:title>
        &lt;/sqf:description>
        <emphasis role="bold">&lt;sqf:delete/></emphasis>
    &lt;/sqf:fix>
&lt;/sch:rule></programlisting>
                    <para>The empty <code>p</code> element will be deleted by the QuickFix
                            <code>delete</code>.</para>
                </example>
                <example>
                    <title>Delete nodes by match Attribute</title>
                    <programlisting>&lt;sch:rule context="title">
    &lt;sch:report test="comment()" 
        sqf:fix="deleteComment"> 
        Comments are not allowed in the &lt;sch:name/> element.&lt;/sch:report>
    &lt;sqf:fix id="deleteComment">
        &lt;sqf:description>
            &lt;sqf:title>Delete the comment.&lt;/sqf:title>
        &lt;/sqf:description>
        <emphasis role="bold">&lt;sqf:delete match="comment()"/></emphasis>
    &lt;/sqf:fix>
&lt;/sch:rule></programlisting>
                    <para>All comments in the <code>title</code> element will be deleted by the
                        QuickFix <code>deleteComment</code>.</para>
                </example>
            </sect3>
            <sect3>
                <title>Replace nodes by new content</title>
                <para>The Activity Element <code>sqf:replace</code> replaces each anchor node by new
                    content. There are three ways to create new content in SQF. In some cases they
                    are also combinable.</para>
                <sect4>
                    <title>By SQF attributes</title>
                    <para>The combination of the attributes <code>node-type</code> and
                            <code>target</code> creates exactly one node. The <code>node-type</code>
                        attribute specifies the kind of the node with the values
                            <code>element</code>, <code>attribute</code>,
                            <code>processing-instruction</code>, <code>pi</code>,
                            <code>comment</code> or <code>keep</code>. The value <code>pi</code> is
                        the short version of the <code>processing-instruction</code>. The value
                            <code>keep</code> is provided, to create the same kind of node, such as
                        the anchor node. </para>
                    <para>If the value of the <code>node-type</code> attribute is not
                            <code>comment</code>, the <code>target</code> attribute is needed to
                        specify the name of the new node. The attribute value will be analyzed like
                        an attribute value template as it is known in XSLT (<uri
                            xlink:href="https://www.w3.org/TR/xslt20/#attribute-value-templates"
                            >https://www.w3.org/TR/xslt20/#attribute-value-templates</uri>) –
                        XPath expression, which is marked with curly brackets
                        (<code>{XPath}</code>), will be evaluated to generate the node name. After
                        evaluation, the value needs to be a valid xs:QName.</para>
                    <para>To specify the value or content of the new node, this way is combinable
                        with one of the other ways to create new content. If the attributes generate
                        an element, the new content, generated by the second way, will be the new
                        content of this element. Otherwise the new content will be transformed to an
                        atomic value (attribute value, comment value, etc.) in the same way, as
                        child nodes of <code>xsl:attribute</code> elements will be transformed to
                        attribute values in XSLT.</para>
                </sect4>
                <sect4>
                    <title>By XPath</title>
                    <para>The <code>select</code> attribute of the Activity Element creates new
                        content by XPath. The given XPath expression will be evaluated in the
                        context of the anchor node. The return value will be used to generate new
                        content. Returned nodes will be copied, atomic values will transformed to
                        text nodes.</para>
                    <para>If the <code>select</code> attribute is set, the Activity Element needs to
                        be empty.</para>
                    <example xml:id="example_create_content1">
                        <title>Create nodes by the SQF attributes and copy nodes by XPath</title>
                        <programlisting>&lt;sch:rule context="b">
    &lt;sch:report test="ancestor::b" 
        sqf:fix="italic"> 
        Bold in bold is not allowed.&lt;/sch:report>
    &lt;sqf:fix id="italic">
        &lt;sqf:description>
            &lt;sqf:title>Change it to italic.&lt;/sqf:title>
        &lt;/sqf:description>
        &lt;sqf:replace<emphasis role="bold"> target="i" node-type="element" select="node()"</emphasis>/>
    &lt;/sqf:fix>
&lt;/sch:rule></programlisting>
                        <para>The recursive <code>b</code> element will be replaced by an
                                <code>i</code> element. The content will be copied.</para>
                    </example>
                </sect4>
                <sect4>
                    <title>By the content</title>
                    <para>If the <code>select</code> attribute is omitted, the content of the
                        Activity Element will be used to create new content. The content will be
                        evaluated as the content of a <code>xsl:template</code> element of XSLT 2.0.
                        That also means that any Element, which are not in the XSLT namespace will
                        be handled as Literal Result Elements. Exceptions are the SQF element
                            <code>sqf:keep</code> and the Schematron elements <code>sch:let</code>,
                            <code>sch:value-of</code> and <code>sch:name</code>. </para>
                    <para>The Schematron elements will be handled, as it is known in Schematron. The
                            <code>sqf:keep</code> Element will copy nodes, which are selected by the
                        XPath expression in the <code>select</code> attribute.</para>
                    <para>The initial context of this "template" will be the anchor node.</para>
                    <example>
                        <title>Create nodes by the content</title>
                        <programlisting>&lt;sqf:fix id="italic">
    &lt;sqf:description>
        &lt;sqf:title>Change it to italic.&lt;/sqf:title>
    &lt;/sqf:description>
    <emphasis role="bold">&lt;sqf:replace>
        &lt;i>
            &lt;sqf:keep select="node()"/>
        &lt;/i>
    &lt;/sqf:replace></emphasis>
&lt;/sqf:fix></programlisting>
                        <para>This example QuickFix does the same actions, such as the QuickFix of
                                <xref linkend="example_create_content1"/>, but uses a different
                            way.</para>
                    </example>
                </sect4>
            </sect3>
            <sect3>
                <title>Add the new content</title>
                <para>To insert new content, without replacing existing nodes, the Activity Element
                        <code>sqf:add</code> is used. It creates new content on the same way, as the
                        <code>sqf:replace</code> element. But the new content will be inserted
                    relative to each anchor node instead of replacing it. </para>
                <para>To specify the exact position, the <code>sqf:add</code> element can have a
                        <code>position</code> attribute, to specify, that the new content will be
                    inserted after (value <code>after</code>), before (value <code>before</code>)
                    the anchor node or as the first (value <code>first-child</code> – default
                    value) or last child (value <code>last-child</code>) of the anchor node. If the
                    new content is an attribute, the <code>position</code> attribute should not be
                    used, because it will always be added as an attribute of the anchor node.</para>
                <example>
                    <title>Add nodes</title>
                    <programlisting>&lt;sch:rule context="h2">
    &lt;sch:assert test="preceding::h1" 
        sqf:fix="addH1"> 
        A h2 should not be used without a h1 before.&lt;/sch:assert>
    &lt;sqf:fix id="addH1">
        &lt;sqf:description>
            &lt;sqf:title>Add a h1 element before the h2 element.&lt;/sqf:title>
        &lt;/sqf:description>
        <emphasis role="bold">&lt;sqf:add node-type="element" target="h1" position="before"/></emphasis>
    &lt;/sqf:fix>
&lt;/sch:rule></programlisting>
                    <para>Directly before the <code>h2</code>, a new <code>h1</code> will be
                        inserted. Because there is no content defined for the new element, the
                            <code>h1</code> will be empty.</para>
                </example>
            </sect3>
            <sect3>
                <title>Replace substrings</title>
                <para>The Activity Element <code>sqf:stringReplace</code> is a special kind. It has
                    a restriction to the anchor nodes, that they need to be text nodes. These text
                    nodes will be analyzed by a regular expression, given in the <code>regex</code>
                    attribute. Each substring of the anchor text node, which matches to the regular
                    expression, will be replaced by new content. The new content will be created,
                    the same way as for the <code>sqf:replace</code> element, though the attributes
                        <code>target</code> and <code>node-type</code> are not available for the
                        <code>sqf:stringReplace</code> element.</para>
                <example>
                    <title>Replace substrings</title>
                    <programlisting>&lt;sch:report test="matches(., '____')" 
    sqf:fix="form"> 
    More than three underscores in a row shouldn't be used.&lt;/sch:report>
&lt;sqf:fix id="form">
    &lt;sqf:description>
        &lt;sqf:title>Replace the missused characters by a form element.&lt;/sqf:title>
    &lt;/sqf:description>
    <emphasis role="bold">&lt;sqf:stringReplace regex="___+">
        &lt;form/>
    &lt;/sqf:stringReplace></emphasis>
&lt;/sqf:fix></programlisting>
                </example>
            </sect3>
        </sect2>
        <sect2>
            <title>Additional features</title>
            <sect3>
                <title>User Entry</title>
                <para>For some solutions of an error, it is impossible to define a QuickFix without
                    more information of the user. For instance, the Schematron error is, that the
                        <code>title</code> element is empty, but it shouldn't. For this case, the
                    solution would be to define a new title. A predefined QuickFix for this issue is
                    impossible because there is an unlimited number of possible titles. The
                    additional input of the user is needed. </para>
                <para>For this case, one or more User Entries can be defined for any QuickFix. The
                    User Entry acts like a parameter, whose value will be set by the user during the
                    execution of the QuickFix.</para>
                <example>
                    <title>User Entry</title>
                    <programlisting>&lt;sch:rule context="title">
    &lt;sch:assert test="normalize-space(.) != ''" 
        sqf:fix="title"> 
        A title shouldn't be empty.&lt;/sch:assert>
    &lt;sqf:fix id="title">
        &lt;sqf:description>
            &lt;sqf:title>Set a title&lt;/sqf:title>
            &lt;sqf:p>This QuickFix will set a title by using a 
                User Entry.&lt;/sqf:p>
        &lt;/sqf:description>
        <emphasis role="bold">&lt;sqf:user-entry name="title">
            &lt;sqf:description>
                &lt;sqf:title>Please enter the new title.
                &lt;/sqf:title>
            &lt;/sqf:description>
        &lt;/sqf:user-entry></emphasis>
        &lt;sqf:replace target="title" node-type="element"
            select="<emphasis role="bold">$title</emphasis>" />
    &lt;/sqf:fix>
&lt;/sch:rule></programlisting>
                </example>
                <para>The <code>sqf:user-entry</code> element has a <code>name</code> attribute and
                    contains <code>sqf:description</code> element. The <code>name</code> attribute
                    specifies the name of the User Entry. For the XPath expressions of all Activity
                    Elements a variable will now be available with the name of the User Entry, which
                    can be used to access to the value of the User Entry.</para>
                <para>The <code>sqf:description</code> element will be used to define a title
                        (<code>sqf:title</code>) and optional an additional description
                        (<code>sqf:p</code> elements) to describe the use case of the User Entry to
                    the user.</para>
            </sect3>
            <sect3>
                <title>Use-when condition</title>
                <para>In some cases the sense of a QuickFix is depending on the context of the
                    error. For one error, the QuickFix makes sense, but for another error of the
                    same kind, it is useless, because it would create another error.</para>
                <example>
                    <title>Useless QuickFix </title>
                    <para>Schematron schema:</para>
                    <programlisting>&lt;sch:rule context="title">
    &lt;sch:report test="exists(b)" 
        sqf:fix="resolveBold deleteBold"> 
        Bold element is not allowed in title.&lt;/sch:report>
    &lt;sch:assert test="normalize-space(.) != ''"> 
         A title shouldn't be empty.&lt;/sch:assert>
    &lt;sqf:fix id="resolveBold">
        &lt;!--...-->
    &lt;/sqf:fix>
    &lt;sqf:fix id="deleteBold">
        &lt;sqf:description>
            &lt;sqf:title>Delete the bold element&lt;/sqf:title>
            &lt;sqf:p>Remove the bold (b) markup including the 
                text content&lt;/sqf:p>
        &lt;/sqf:description>
        &lt;sqf:delete match="b"/>
    &lt;/sqf:fix>
&lt;/sch:rule></programlisting>
                    <para>XML instance:</para>
                    <programlisting>&lt;article>
    &lt;section>
        &lt;title>&lt;b>This title should be bold&lt;/b>&lt;/title>
    &lt;/section>
    &lt;section>
        &lt;title>This title should be bold&lt;b/>&lt;/title>
    &lt;/section>
&lt;/article></programlisting>
                    <para>Both titles will produce the same error, but for the first title, the
                        QuickFix <code>deleteBold</code> is useless, because after the execution the
                            <code>title</code> element would be empty and would produce another kind
                        of error, caused by the <code>sch:assert</code> element.</para>
                </example>
                <para>To avoid such a subsequent error, the use-when condition helps. The XPath
                    expression in the <code>use-when</code> attribute of the <code>sqf:fix</code>
                    element is a condition to provide the QuickFix: </para>
                <example>
                    <title>Use-when condition</title>
                    <programlisting>&lt;sqf:fix id="deleteBold"
    <emphasis role="bold">use-when="node()[normalize-space(.) != ''] except b"</emphasis>>
    &lt;sqf:description>
        &lt;sqf:title>Delete the bold element&lt;/sqf:title>
        &lt;sqf:p>Remove the bold (b) markup including the 
            text content&lt;/sqf:p>
    &lt;/sqf:description>
    &lt;sqf:delete match="b"/>
&lt;/sqf:fix></programlisting>
                    <para>The QuickFix <code>deleteBold</code> will be proposed to the user, only if
                        the <code>title</code> element has a node, which is not a <code>b</code>
                        element and contains other text than whitespace.</para>
                </example>
                <para>The <code>use-when</code> attribute is also available for each Activity
                    Element, so the developer is able to specify use-when conditions for each single
                    Activity Element.</para>
            </sect3>
        </sect2>
    </sect1>
    <sect1>
        <title>Projects using SQF</title>
        <para>There are some projects available that use the SQF language to propose fixes:</para>
        <itemizedlist>
            <listitem>
                <para>Dynamic Information Model (DIM) project (<link
                        xlink:href="https://github.com/oxygenxml/dim"
                        >https://github.com/oxygenxml/dim</link>) – uses SQF to propose quick fixes
                    for the Schematron rules.</para>
            </listitem>
            <listitem>
                <para>TEI (<link xlink:href="http://wiki.tei-c.org/index.php/Category:Schematron"
                        >http://wiki.tei-c.org/index.php/Category:Schematron</link>) – a page that
                    contains Schematron schemas and SQF that can be used to determine and fix
                    various problems in TEI documents.</para>
            </listitem>
            <listitem>
                <para>&lt;oXygen/> DITA framework – a built-in framework in oXygen XML Editor for
                    DITA documents and it also contains a set of Schematron schemas and SQF fixes
                    that can be used to impose rules and propose fixes to solve errors.</para>
            </listitem>
            <listitem>
                <para>&lt;oXygen/> User Manual (<link
                        xlink:href="https://github.com/oxygenxml/userguide"
                        >https://github.com/oxygenxml/userguide</link>) – a public version of the
                    oXygen XML Editor user guide that provides an example where SQF rules have been
                    implemented on a DITA project.</para>
            </listitem>
        </itemizedlist>
    </sect1>
    <sect1>
        <title>Conclusions and Future Plans</title>
        <para>In the near future, we plan to publish the second draft of the Schematron QuickFix
            specification that will contain new things such as how you can execute fixes on other
            documents, new definitions, and examples for the SQF elements.</para>
        <para>We intend to update the specification and add other elements or change their behavior,
            based upon discussions and feedback that we have received on the <link
                xlink:href="https://github.com/schematron-quickfix/sqf">SQF GitHub project</link>.
            For example, the <emphasis>call-fix</emphasis> element will be able to reference a group
            of operations and support will be added to allow you to generate the fixes
            dynamically.</para>
    </sect1>
</article>

